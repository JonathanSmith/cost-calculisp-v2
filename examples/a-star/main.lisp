(in-package :cost)

(defmethod cost ((node null))
  most-positive-fixnum)

(with-generation  ($ENGINE)
  ($define A* (node)
    (choice ((typep node 'A*-goal) node)
	    ((not (typep node 'A*-goal)) (A* (min node))))))

(defun run-example (node)
  (setf *all-nodes* (make-hash-table))
  (setf *queue* (list))
  (goal A 5 2 B C)
  (location B 6 7 C D A)
  (location C 3 4 E B A)
  (location D 4 6 B E)
  (location E 2 4 C D F)
  (location F 6 1 E G)
  (location G 0 8 F)
  (let* ((solution (A* (get-loc node))))
    (pprint (mapcar #'node-name (concatenate 'list (ancestors solution) (list solution))))
    solution))

(defun generate-random-traversal-graph (nodes degree max-x max-y) 
  (let ((graph (graph-utils:generate-random-graph :viger-latapy nodes :degree degree))
	(code (list)))
    (let ((i 1))
      (graph-utils:map-nodes #'(lambda (name id)
				 (declare (ignore name))
				 (if (= i nodes)
				     (push `(goal ,id ,(random max-x) ,(random max-y) ,@(graph-utils:neighbors graph id)) code)
				     (push `(location ,id ,(random max-x) ,(random max-y) ,@(graph-utils:neighbors graph id)) code))
				 (incf i)) graph))
    `(let ((*all-nodes* (make-hash-table))
	   (*queue* (list)))
       ,@code
       (let ((solution (time (A* (get-loc ,(random (- nodes 1)))))))
	 (pprint (cost solution))
	 (pprint (mapcar #'node-name (concatenate 'list (ancestors solution) (list solution))))))))

(defun cl-user::run-1000-3()
  (let ((k (generate-random-traversal-graph 1000 3 10000 10000)))
    (pprint k)
    (eval k)))

(defun cl-user::run-1000-10()
  (let ((k (generate-random-traversal-graph 1000 10 10000 10000)))
    (pprint k)
    (eval k)))
